\documentclass[10pt,landscape, a4paper]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage{setspace}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage{graphicx}
\usepackage{listings}



\geometry{top=.2in,left=.5in,right=.5in,bottom=.2in} 
\usepackage{lmodern}
\usepackage{listings}
\lstset{language=C,
numberstyle=\footnotesize,
basicstyle=\footnotesize,
stepnumber=1,
breaklines=true}
%\usepackage[subsection]{placeins}
\usepackage{float}

\pagestyle{empty}

\lstset{basicstyle=\footnotesizev,breaklines=true}
\lstset{framextopmargin=50pt}

\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\setcounter{secnumdepth}{0}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

\newcommand{\mysinglespacing}{%
  \setstretch{1}% no correction afterwards
}

\lstset{
         basicstyle=\footnotesize\ttfamily, 
         numberstyle=\tiny,          
         numbersep=2pt,             
         tabsize=2,                
         extendedchars=true,      
         breaklines=true,        
         showspaces=false,      
         showtabs=false,       
         xleftmargin=0pt,
         framexleftmargin=0pt,
         framexrightmargin=0pt,
         framexbottommargin=0pt,
         showstringspaces=false 
         basicstyle=\tiny
 }

\lstloadlanguages{
         C
 }

\begin{document}



% Using Courier font
\renewcommand{\ttdefault}{cmtt}

\raggedright
\footnotesize
\begin{multicols}{3}

\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
     \Large{\textbf{Systems Programming Cheat Sheet}} \\
\end{center}

\section{Mutex locks}

A \emph{mutex} is a lock that we set before using a shared resource and release after using it. 
When the lock is set, \emph{no other thread can access the locked region of code}. 
So we see that even if thread 2 is scheduled while thread 1 was not done accessing 
the shared resource and the code is locked by thread 1 using mutexes then thread 2 
cannot even access that region of code. So this \emph{ensures a synchronized access of shared resources in the code}.

\lstinputlisting[language=C]{snippets/mutex.c}

A mutex contains three things: A flag which is a 0 or a 1 (locked or unlocked), 
Owner which is a thread ID, Queue which holds suspended threads. 
It can only be unlocked by what has locked it.

\section{Signal handling}

A {\bf signal} is a condition that may be reported during program execution, 
and can be ignored, handled specially, or, as is the default, 
used to terminate the program.

\lstinputlisting[language=C]{snippets/signal.c}

\section{Multiprogramming}

Forking returns the ID of the new process. The child process gets its
very own process ID. One process calls fork, and if the return is negative
one, the fork failed, if it's zero, you're in the child, and if it's anything
larger than 0, you have the process ID of the child.

\subsection{Fork}

The \texttt{fork()} system call will spawn a new child process which is an 
identical process to the parent except that has a new system process ID. 
The process is copied in memory from the parent and a new process structure 
is assigned by the kernel. The return value of the function is which 
discriminates the two threads of execution. A zero is returned by the 
fork function in the child's process.

The environment, resource limits, umask, controlling terminal, 
current working directory, root directory, signal masks and other 
process resources are also duplicated from the parent in the forked 
child process.

\lstinputlisting[language=C]{snippets/fork.c}

\subsection{Exec}

The \texttt{exec()} family of functions will initiate a program from within a program. 
They are also various front-end functions to \texttt{execve()}.

The functions return an integer error code.

The function call \texttt{execl()} initiates a new program in the same environment 
in which it is operating. An executable (with fully qualified path. i.e. \texttt{/bin/ls}) 
and arguments are passed to the function. Note that \texttt{arg0} is the command/file 
name to execute.

Use \texttt{exec} to make a child process execute a new program
after it has been forked. It usually does not return, with \texttt{-1}
on failure. It will fail when: too big, ACCESS, get into a loop, the name
is too long, or the executable does not exist. The new process keeps the
set of blocked signals, pending signals, timers, and any open file 
descriptors. Doing an \texttt{exec} does not change the relationship
between a parent and child process. Caught signals return default values.

\lstinputlisting[language=C]{snippets/exec.c}

\subsection{Wait}

\texttt{wait()}: Blocks calling process \emph{until the child process terminates}. 
If child process has already terminated, the wait() call returns immediately. 
if the calling process has multiple child processes, the function returns when one returns.

\texttt{waitpid()}: Options available to block calling process for a particular 
child process not the first one.

\section{Shell scripting}
\section{Shared memory}

Possible for multiple processes to share segments of memory, 
not full memory. Beneficial for better speed. Access by multiple processes.
Still need mutexes and semaphore for synchronizations. 
Lifetime is independent of any process. All shared memory segments 
exist in a single list. Identified by a key, generated by the metainfo of 
files and directories. Processes attach and detach to shared memory segments.

\section{Pointers to functions}

\lstinputlisting[language=C]{snippets/funcpoint.c}

\section{Condition variables}
\emph{Condition variables} provide yet another way for threads to synchronize. 
While mutexes implement synchronization by controlling thread access to data, 
condition variables \emph{allow threads to synchronize based upon the actual value of data}.

Without condition variables, the programmer would need to have threads 
continually polling (possibly in a critical section), to check if the 
condition is met. This can be very resource consuming since the thread 
would be continuously busy in this activity. \emph{A condition variable is a 
way to achieve the same goal without polling.}

A condition variable is \emph{always used in conjunction with a mutex lock}.

Used for waiting. Contains 3 basic operations: wait, signal, broadcast. 
Wait atomically does unlock and block. Signal atomically does re-locks a 
thread has it start again.

\section{Deadlock}

Four conditions for deadlock: \textbf{mutual exclusion} (At least one resource must be held in a non-sharable mode. Only one process can use the resource at any given instant of time.), \textbf{circular wait} (A process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource.), \textbf{no pre-emption} (The operating system must not de-allocate resources once they have been allocated; they must be released by the holding process voluntarily.), \textbf{hold and wait} (A process is currently holding at least one resource and requesting additional resources which are being held by other processes.). 

\section{Semaphores}

A \emph{semaphore} is a special type of variable that can be incremented or decremented, 
but \emph{crucial access to the variable is guaranteed to be atomic}, even in a multi-threaded program.
If two or more threads in a program attempt to change the value of a semaphore, 
the system guarantees that all the operations will in fact \emph{take place in sequence}.

Contains a counter,not an owner. The counter is anything that is non-negative and can be 
posted by anything. Wait has two checks: if counter is not zero, decrement and return 
immediately, but if it is zero then suspend the calling thread and put it in the 
semaphore queue. 

\end{multicols}
\end{document}
